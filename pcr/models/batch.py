from django.utils.timezone import now
from django.db import models
from django.core.validators import MinValueValidator
from django.utils.translation import gettext_lazy as _
from users.models import User

from .assay import AssayCode, Assay
from .extraction import ExtractionProtocol

# Batches can only be created and deleted. If changes such as lab ID or number of samples must be made to a batch it must be deleted and created again.
# A batch is a set of samples with the extraction protocol where sample assays can be individually added/removed
class Batch(models.Model):
  user = models.ForeignKey(User, on_delete=models.CASCADE)

  # Batch refers to a list of samples that are to be extracted
  name = models.CharField(blank=False, max_length=25)
  lab_id = models.CharField(blank=False, max_length=5) # This will be a short STRING to be shown on the plate such as ABC

  code = models.ForeignKey(AssayCode, on_delete=models.RESTRICT) # a batch can only refer to one list of assays (AssayList) - but users can individually edit samples after
  extraction_protocol = models.ForeignKey(ExtractionProtocol, on_delete=models.RESTRICT)

  is_extracted = models.BooleanField(default=False) #If True all samples have been extracted and is ready for PCR.

  date_created = models.DateTimeField(default=now, editable=False)
  
  class Meta:
    constraints = [
      models.UniqueConstraint(
        fields=['user', 'lab_id'], 
        name='batch_unique',
        violation_error_message = "A batch with this lab ID already exists."
      )
    ]

  @property
  def number_of_samples(self):
    return f"{self.sample_set.count() - 1} + 1"

  @property
  def number_of_assays(self):
    return self.code.assays.count()

  @property
  def total_tests(self):
    number_of_assays = self.code.assays.count()
    number_of_samples = self.sample_set.count()
    total_expected = number_of_samples * number_of_assays

    total_tests = 0
    for sample in self.sample_set.all():
      total_tests += sample.assays.count()

    remains = total_tests - total_expected

    if total_tests == total_expected:
      return total_expected
    elif remains < 0:
      return f"{total_expected} - {abs(remains)}"
    else:
      return f"{total_expected} + {remains}"

  def __str__(self):
    return f'{self.name}-{self.lab_id}'


class Sample(models.Model):
  user = models.ForeignKey(User, on_delete=models.CASCADE)

  lab_id_num = models.CharField(blank=False, max_length=10) # lab id with number - auto generated by combining lab_id from Batch and adding a number to it
  sample_id = models.CharField(blank=True, max_length=25) # actual id of sample - manually generated by user by turning csv into html or copy/paste (JS)

  assays = models.ManyToManyField(Assay) # assays assigned to each sample according to AssayList assigned in Batch - users can also edit samples at this stage and add individual assays

  batch = models.ForeignKey(Batch, on_delete=models.CASCADE) # automatically assigned to newly created batch - cannot be changed

  class Meta:
    constraints = [
      models.UniqueConstraint(
        fields=['user', 'lab_id_num'], 
        name='user_lab_id_unique',
        violation_error_message = "A batch with this lab ID already exists.",
      )
    ]

  def __str__(self):
    return self.lab_id_num